using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Libplanet.Serialization.Analyzers;

[Generator]
public sealed class ModelIncrementalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var modelClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: Predicate,
                transform: static (ctx, _) => (
                    Declaration: (TypeDeclarationSyntax)ctx.Node,
                    IsPartial: ((TypeDeclarationSyntax)ctx.Node).Modifiers.Any(SyntaxKind.PartialKeyword),
                    ctx.SemanticModel
                ));

        context.RegisterSourceOutput(modelClasses, (spc, classInfo) =>
        {
            var declaration = classInfo.Declaration;
            var semanticModel = classInfo.SemanticModel;
            if (!IsModelObject(declaration, semanticModel))
            {
                return;
            }

            if (declaration.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                var identifier = declaration.Identifier.ValueText;
                var sourceName = $"{identifier}.g.cs";
                var source = GenerateSource(declaration, semanticModel);
                var sourceText = SourceText.From(source, Encoding.UTF8);
                spc.AddSource(sourceName, sourceText);
            }
            else
            {
                var descriptor = new DiagnosticDescriptor(
                    id: "LIBP1001",
                    title: "Model class must be declared as partial",
                    messageFormat: "The class '{0}' with [Libplanet.Serialization.ModelAttribute] attribute must be declared as partial",
                    category: "Libplanet.Serialization",
                    defaultSeverity: DiagnosticSeverity.Error,
                    isEnabledByDefault: true);

                var diagnostic = Diagnostic.Create(
                    descriptor,
                    declaration.GetLocation(),
                    declaration.Identifier.Text);

                spc.ReportDiagnostic(diagnostic);
            }
        });
    }

    private static string GenerateSource(TypeDeclarationSyntax declaration, SemanticModel semanticModel)
    {
        using var tw = new IndentedTextWriter();
        var ns = declaration.GetNamespace();
        var name = declaration.GetName();

        tw.WriteLine("// <auto-generated/>");
        tw.WriteLine("// This file is auto-generated by Libplanet.Serialization.Analyzers.ModelIncrementalGenerator.");
        tw.WriteLine("// Do not edit this file manually.");
        tw.WriteLine();

        if (ns != string.Empty)
        {
            tw.WriteLine($"namespace {ns}");
            tw.WriteLine("{");
            tw.Indent();
        }

        if (declaration.IsPublic())
        {
            tw.Write("public ");
        }
        else if (declaration.IsInternal())
        {
            tw.Write("internal ");
        }
        else if (declaration.IsProtected())
        {
            tw.Write("protected ");
        }
        else if (declaration.IsPrivate())
        {
            tw.Write("private ");
        }

        tw.Write("partial ");

        if (declaration.IsRecord())
        {
            if (declaration.IsStruct())
            {
                tw.Write("record struct ");
            }
            else if (declaration.IsClass())
            {
                tw.Write("record class ");
            }
            else
            {
                tw.Write("record ");
            }
        }
        else if (declaration.IsClass())
        {
            tw.Write("class ");
        }
        else if (declaration.IsStruct())
        {
            tw.Write("struct ");
        }

        tw.Write(@$"{name}");

        if (!IsEuquatableInterfaceDefined(declaration, semanticModel))
        {
            tw.Write(" : System.IEquatable<" + name + ">");
        }

        tw.WriteLine();
        tw.WriteLine("{");
        tw.Indent();

        if (!IsGetHashCodeMethodDefined(declaration))
        {
            tw.WriteLine("public override int GetHashCode()");
            tw.Indent();
            tw.WriteLine("=> Libplanet.Serialization.ModelResolver.GetHashCode(this);");
            tw.Unindent();
            tw.WriteLine();
        }

        if (!IsEquatableMethodDefined(declaration, semanticModel))
        {
            if (declaration.IsStruct())
            {
                tw.WriteLine($"bool System.IEquatable<{name}>.Equals({name} other)");
                tw.Indent();
                tw.WriteLine("=> Libplanet.Serialization.ModelResolver.Equals(this, other);");
                tw.Unindent();
            }
            else
            {
                tw.WriteLine($"bool System.IEquatable<{name}>.Equals({name}? other)");
                tw.Indent();
                tw.WriteLine("=> Libplanet.Serialization.ModelResolver.Equals(this, other);");
                tw.Unindent();
            }

            tw.WriteLine();
        }

        tw.Unindent();
        tw.WriteLine("}");

        if (ns != string.Empty)
        {
            tw.Unindent();
            tw.WriteLine("}");
        }

        tw.WriteLine();

        return tw.ToString();
    }

    private static bool Predicate(SyntaxNode node, CancellationToken _)
    {
        if (node is not TypeDeclarationSyntax typeDecl)
        {
            return false;
        }

        return typeDecl.AttributeLists.Count > 0;
    }

    private static bool IsModelObject(TypeDeclarationSyntax typeDeclaration, SemanticModel semanticModel)
    {
        var query = from attributeList in typeDeclaration.AttributeLists
                    from attribute in attributeList.Attributes
                    let symbol = semanticModel.GetSymbolInfo(attribute).Symbol as IMethodSymbol
                    where symbol != null
                    let attributeType = symbol.ContainingType
                    where attributeType.ToDisplayString() == "Libplanet.Serialization.ModelAttribute"
                    select attributeType;

        return query.Any();
    }

    private static bool IsEuquatableInterfaceDefined(TypeDeclarationSyntax declaration, SemanticModel semanticModel)
    {
        var symbol = semanticModel.GetDeclaredSymbol(declaration);
        if (symbol is null)
        {
            return false;
        }

        return symbol.Interfaces.Any(i => i.ToDisplayString() == "System.IEquatable<" + declaration.GetName() + ">");
    }

    private static bool IsGetHashCodeMethodDefined(TypeDeclarationSyntax declaration)
    {
        var methodSyntax = declaration.Members
            .OfType<MethodDeclarationSyntax>()
            .FirstOrDefault(m =>
                m.Identifier.ValueText == "GetHashCode" &&
                m.ParameterList.Parameters.Count == 0 &&
                m.Modifiers.Any(SyntaxKind.OverrideKeyword));

        if (methodSyntax != null)
        {
            return true;
        }

        return false;
    }

    private static bool IsEquatableMethodDefined(TypeDeclarationSyntax declaration, SemanticModel semanticModel)
    {
        var symbol = semanticModel.GetDeclaredSymbol(declaration);
        if (symbol is null)
        {
            return false;
        }

        return symbol.GetMembers("Equals").Any(Predicate);

        bool Predicate(ISymbol symbol)
        {
            if (symbol is not IMethodSymbol methodSymbol)
            {
                return false;
            }

            if (methodSymbol.MethodKind != MethodKind.Ordinary)
            {
                return false;
            }

            if (methodSymbol.Parameters.Length != 1)
            {
                return false;
            }

            if (methodSymbol.Parameters[0].Type.ToDisplayString() != declaration.GetName())
            {
                return false;
            }

            return true;
        }
    }
}
