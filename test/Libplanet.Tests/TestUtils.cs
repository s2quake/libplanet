using System.IO;
using System.Linq.Expressions;
using System.Security.Cryptography;
using System.Text.Json;
using System.Text.Json.JsonDiffPatch.Xunit;
using System.Text.Json.Nodes;
using System.Threading.Tasks;
using Libplanet.State;
using Libplanet.State.Builtin;
using Libplanet.Data;
using Libplanet.Types;
using Xunit.Abstractions;
using Libplanet.TestUtilities.Extensions;

namespace Libplanet.Tests;

public static class TestUtils
{
    public static readonly ImmutableList<PrivateKey> ValidatorPrivateKeys =
    [
        PrivateKey.Parse("e5792a1518d9c7f7ecc35cd352899211a05164c9dde059c9811e0654860549ef"),
        PrivateKey.Parse("91d61834be824c952754510fcf545180eca38e036d3d9b66564f0667b30d5b93"),
        PrivateKey.Parse("b17c919b07320edfb3e6da2f1cfed75910322de2e49377d6d4d226505afca550"),
        PrivateKey.Parse("91602d7091c5c7837ac8e71a8d6b1ed1355cfe311914d9a76107899add0ad56a"),
    ];

    public static readonly ImmutableSortedSet<Validator> Validators =
    [
        .. ValidatorPrivateKeys.Select(privateKey => new Validator { Address = privateKey.Address })
    ];

    // These keys are used to generate a situation that two adjacent peers generated by these
    // keys are in different buckets in routing table of Kademlia Protocol.
    public static readonly PrivateKey[] AdjacentKeys =
    [
        new PrivateKey(
        [
            0x98, 0x66, 0x98, 0x50, 0x72, 0x8c, 0x6c, 0x41, 0x0b, 0xf4,
            0x2c, 0x45, 0xfe, 0x7c, 0x49, 0x23, 0x2d, 0x14, 0xcf, 0xb5,
            0x5b, 0x78, 0x4d, 0x81, 0x35, 0xae, 0x40, 0x4c, 0x7c, 0x24,
            0x3f, 0xc7,
        ]),
        new PrivateKey(
        [
            0xd2, 0x47, 0x6f, 0xf3, 0x1a, 0xf3, 0x4f, 0x00, 0x5a, 0xe2,
            0xd9, 0x24, 0x18, 0x60, 0xe9, 0xb9, 0xd0, 0x42, 0x9a, 0x30,
            0x67, 0x81, 0x2b, 0x00, 0xf0, 0x45, 0x87, 0x70, 0x3f, 0xd5,
            0x51, 0x93,
        ]),
        new PrivateKey(
        [
            0x9e, 0xd4, 0xdb, 0x20, 0xfd, 0x4d, 0x1c, 0x52, 0x55, 0x24,
            0x80, 0x52, 0xc6, 0x1f, 0x95, 0x1c, 0xf1, 0x49, 0x4a, 0xd6,
            0xf9, 0x1d, 0x29, 0xb9, 0xa3, 0x0b, 0x0e, 0x0c, 0xc8, 0xaa,
            0xb0, 0x79,
        ]),
        new PrivateKey(
        [
            0x0a, 0x4f, 0x84, 0xeb, 0x69, 0x4d, 0xc1, 0xf0, 0xf3, 0x15,
            0x97, 0xcc, 0x95, 0x53, 0x66, 0x01, 0x27, 0x2a, 0xc1, 0xcd,
            0x0f, 0xf6, 0x02, 0x6f, 0x08, 0x29, 0x1d, 0xd0, 0x79, 0xda,
            0xcc, 0x36,
        ]),
        new PrivateKey(
        [
            0x68, 0xbd, 0xc3, 0xda, 0xf1, 0xa1, 0x67, 0x9c, 0xa1, 0x1e,
            0x5a, 0x64, 0x10, 0xe6, 0x74, 0x95, 0x77, 0xbc, 0x47, 0x1c,
            0x55, 0xd7, 0x38, 0xa3, 0x67, 0x48, 0x73, 0x08, 0xcd, 0x74,
            0x3c, 0x4b,
        ]),
        new PrivateKey(
        [
            0x02, 0x40, 0xa6, 0x72, 0xdd, 0xc0, 0x65, 0x04, 0x54, 0xfb,
            0x34, 0x29, 0x05, 0xaa, 0xa6, 0x1e, 0x94, 0x30, 0x89, 0x26,
            0xfd, 0x30, 0xd1, 0x61, 0x8c, 0x1b, 0x75, 0x79, 0x86, 0xf8,
            0x8a, 0x6a,
        ]),
        new PrivateKey(
        [
            0x74, 0x6d, 0x07, 0xb0, 0xb9, 0x7e, 0x0d, 0xb9, 0x1f, 0x96,
            0x59, 0xe1, 0x20, 0x8d, 0x31, 0xac, 0x94, 0xcd, 0xc8, 0xaa,
            0x0c, 0x0d, 0xeb, 0x35, 0xab, 0x93, 0x95, 0x65, 0xae, 0x5f,
            0xc1, 0x4b,
        ]),
        new PrivateKey(
        [
            0xc5, 0x1e, 0xc4, 0x6c, 0x81, 0x6a, 0x9d, 0x41, 0xc2, 0xae,
            0x61, 0x51, 0x0f, 0x97, 0xd0, 0x0e, 0x3a, 0x7b, 0x86, 0xd3,
            0xbd, 0xf1, 0x1e, 0xfe, 0x55, 0x67, 0x8f, 0x31, 0x92, 0xc1,
            0xdf, 0xe4,
        ]),
        new PrivateKey(
        [
            0x0a, 0x9e, 0x67, 0x59, 0x4b, 0xfc, 0xdd, 0x81, 0xcd, 0x86,
            0xa0, 0xf1, 0x79, 0x74, 0x56, 0x0f, 0x56, 0x85, 0xff, 0x3f,
            0x75, 0xd3, 0xbc, 0xaa, 0xf0, 0xa2, 0xec, 0xdb, 0x05, 0xa5,
            0x59, 0x79,
        ]),
        new PrivateKey(
        [
            0x3d, 0xae, 0x2d, 0x2f, 0x87, 0x1b, 0x11, 0xaa, 0x41, 0xbd,
            0xec, 0x81, 0x4c, 0x4d, 0x27, 0xf3, 0xba, 0xd9, 0x1f, 0x61,
            0xc3, 0x57, 0xab, 0x43, 0xa0, 0x0c, 0x63, 0x1b, 0x2b, 0x15,
            0x13, 0xf2,
        ]),
    ];

    public static PrivateKey GenesisProposer => ValidatorPrivateKeys[0];

    public static BlockCommit CreateBlockCommit(
        Block block,
        bool deterministicTimestamp = false)
    {
        var useValidatorPower = true;
        return CreateBlockCommit(
            block.BlockHash, block.Height, 0, deterministicTimestamp, useValidatorPower);
    }

    public static BlockCommit CreateBlockCommit(
        BlockHash blockHash,
        int height,
        int round,
        bool deterministicTimestamp = false,
        bool useValidatorPower = true)
    {
        // Index #1 block cannot have lastCommit: There was no consensus of genesis block.
        if (height == 0)
        {
            return BlockCommit.Empty;
        }

        // Using the unix epoch time as the timestamp of the vote if deterministicTimestamp is
        // flagged for getting a deterministic random value from RawHash.
        var votes = ValidatorPrivateKeys.Select(key => new VoteMetadata
        {
            Height = height,
            Round = round,
            BlockHash = blockHash,
            Timestamp = deterministicTimestamp ? DateTimeOffset.UnixEpoch : DateTimeOffset.UtcNow,
            Validator = key.Address,
            ValidatorPower = useValidatorPower ? Validators.GetValidator(key.Address).Power : 0,
            Type = VoteType.PreCommit,
        }.Sign(key)).ToImmutableArray();

        return new BlockCommit
        {
            Height = height,
            Round = round,
            BlockHash = blockHash,
            Votes = votes,
        };
    }

    public static RawBlock ProposeGenesis(
        PrivateKey proposer,
        HashDigest<SHA256> previousStateRootHash = default,
        ImmutableSortedSet<Transaction>? transactions = null,
        ImmutableSortedSet<Validator>? validators = null,
        DateTimeOffset? timestamp = null,
        int protocolVersion = BlockHeader.CurrentProtocolVersion)
    {
        var txs = transactions ?? [];
        long nonce = txs.Count(tx => tx.Signer.Equals(GenesisProposer.Address));
        validators ??= Validators;
        txs = txs.Add(
            new TransactionMetadata
            {
                Nonce = nonce,
                Signer = GenesisProposer.Address,
                Actions = new[]
                {
                    new Initialize
                    {
                        Validators = validators ?? [],
                    },
                }.ToBytecodes(),
                Timestamp = DateTimeOffset.MinValue,
            }.Sign(GenesisProposer));

        var metadata = new BlockHeader
        {
            BlockVersion = protocolVersion,
            Timestamp = timestamp ??
                    new DateTimeOffset(2018, 11, 29, 0, 0, 0, TimeSpan.Zero),
            Proposer = proposer.Address,
            PreviousStateRootHash = previousStateRootHash,
        };
        var content = new BlockContent
        {
            Transactions = [.. txs],
            Evidences = [],
        };
        return new RawBlock { Header = metadata, Content = content };
    }

    public static Block ProposeGenesisBlock(
        PrivateKey proposer,
        HashDigest<SHA256> previousStateRootHash = default,
        ImmutableSortedSet<Transaction>? transactions = null,
        DateTimeOffset? timestamp = null,
        int protocolVersion = BlockHeader.CurrentProtocolVersion)
    {
        var rawBlock = ProposeGenesis(
            proposer: proposer,
            previousStateRootHash: previousStateRootHash,
            transactions: transactions,
            validators: null,
            timestamp: timestamp,
            protocolVersion);
        return rawBlock.Sign(proposer);
    }

    public static RawBlock ProposeNext(
        Block previousBlock,
        HashDigest<SHA256> previousStateRootHash,
        ImmutableSortedSet<Transaction>? transactions = null,
        PrivateKey? proposer = null,
        TimeSpan? blockInterval = null,
        int protocolVersion = BlockHeader.CurrentProtocolVersion,
        BlockCommit? previousCommit = null,
        ImmutableSortedSet<EvidenceBase>? evidence = null)
    {
        var txs = transactions ?? [];
        var evs = evidence ?? [];
        var metadata = new BlockHeader
        {
            BlockVersion = protocolVersion,
            Height = previousBlock.Height + 1,
            Timestamp = previousBlock.Timestamp.Add(
                    blockInterval ?? TimeSpan.FromSeconds(15)),
            Proposer = proposer?.Address ?? previousBlock.Proposer,
            PreviousHash = previousBlock.BlockHash,
            PreviousCommit = previousCommit ?? BlockCommit.Empty,
            PreviousStateRootHash = previousStateRootHash,
        };
        var content = new BlockContent
        {
            Transactions = txs,
            Evidences = evs,
        };
        var preEval = new RawBlock { Header = metadata, Content = content };
        preEval.Header.Timestamp.ValidateTimestamp();
        return preEval;
    }

    public static Block ProposeNextBlock(
        Block previousBlock,
        PrivateKey proposer,
        ImmutableSortedSet<Transaction>? txs = null,
        TimeSpan? blockInterval = null,
        int protocolVersion = BlockHeader.CurrentProtocolVersion,
        HashDigest<SHA256> previousStateRootHash = default,
        BlockCommit? lastCommit = null,
        ImmutableSortedSet<EvidenceBase>? evidence = null)
    {
        Skip.IfNot(
            Environment.GetEnvironmentVariable("XUNIT_UNITY_RUNNER") is null,
            "Flaky test : Libplanet.Blocks.InvalidBlockSignatureException");

        RawBlock preEval = ProposeNext(
            previousBlock,
            previousStateRootHash: previousStateRootHash,
            transactions: txs,
            proposer: proposer,
            blockInterval: blockInterval,
            protocolVersion: protocolVersion,
            previousCommit: lastCommit,
            evidence: evidence);
        return preEval.Sign(proposer);
    }

    public static Libplanet.Blockchain MakeBlockChain(
        BlockchainOptions? options = null,
        IEnumerable<IAction>? actions = null,
        ImmutableSortedSet<Validator>? validatorSet = null,
        PrivateKey? privateKey = null,
        DateTimeOffset? timestamp = null,
        Block? genesisBlock = null,
        int protocolVersion = BlockHeader.CurrentProtocolVersion)
    {
        return MakeBlockChainAndBlockExecutor(
            options,
            actions,
            validatorSet,
            privateKey,
            timestamp,
            genesisBlock,
            protocolVersion)
        .BlockChain;
    }

    public static (Libplanet.Blockchain BlockChain, BlockExecutor BlockExecutor)
        MakeBlockChainAndBlockExecutor(
        BlockchainOptions? options,
        IEnumerable<IAction>? actions = null,
        ImmutableSortedSet<Validator>? validatorSet = null,
        PrivateKey? privateKey = null,
        DateTimeOffset? timestamp = null,
        Block? genesisBlock = null,
        int protocolVersion = BlockHeader.CurrentProtocolVersion)
    {
        options ??= new BlockchainOptions();
        actions ??= ImmutableArray<IAction>.Empty;
        privateKey ??= GenesisProposer;

        var txs = new[]
        {
            new TransactionMetadata
            {
                Nonce = 0,
                Signer = privateKey.Address,
                GenesisHash = default,
                Actions = actions.ToBytecodes(),
                Timestamp = timestamp ?? DateTimeOffset.MinValue,
            }.Sign(privateKey),
        }.ToImmutableSortedSet();

        var repository = new Repository();
        var blockExecutor = new BlockExecutor(
            states: repository.States,
            options.SystemActions);

        if (genesisBlock is null)
        {
            var preEval = ProposeGenesis(
                proposer: privateKey,
                transactions: txs,
                validators: validatorSet,
                timestamp: timestamp,
                protocolVersion: protocolVersion);
            var evaluation = blockExecutor.Execute(preEval);
            genesisBlock = preEval.Sign(privateKey);
        }

        var chain = new Libplanet.Blockchain(genesisBlock, repository, options);

        return (chain, blockExecutor);
    }

    public static async Task AssertThatEventually(
        Expression<Func<bool>> condition,
        TimeSpan timeout,
        TimeSpan delay,
        ITestOutputHelper? output = null,
        string? conditionLabel = null)
    {
        Func<bool> conditionFunc = condition.Compile();
        DateTimeOffset started = DateTimeOffset.UtcNow;
        DateTimeOffset until = started + timeout;
        while (!conditionFunc() && DateTimeOffset.UtcNow <= until)
        {
            output?.WriteLine(
                "[{0}/{1}] Waiting for {2}...",
                DateTimeOffset.UtcNow - started,
                timeout,
                conditionLabel is string c1
                    ? c1
                    : $"satisfying the condition ({condition.Body})");
            await Task.Delay(delay);
        }

        Assert.True(
            conditionFunc(),
            $"Waited {timeout} but the condition (" +
                (conditionLabel is string l ? l : condition.Body.ToString()) +
                ") has never been satisfied.");

        output?.WriteLine(
            "[{0}/{1}] Done {2}...",
            DateTimeOffset.UtcNow - started,
            timeout,
            conditionLabel is string c2 ? c2 : $"satisfying the condition ({condition.Body})");
    }

    public static Task AssertThatEventually(
        Expression<Func<bool>> condition,
        int timeoutMilliseconds,
        int delayMilliseconds = 100,
        ITestOutputHelper? output = null,
        string? conditionLabel = null) =>
        AssertThatEventually(
            condition,
            TimeSpan.FromMilliseconds(timeoutMilliseconds),
            TimeSpan.FromMilliseconds(delayMilliseconds),
            output,
            conditionLabel);

    public static void AssertJsonSerializable<T>(
        T obj,
        string expectedJson,
        bool testDeserializable = true)
        where T : IEquatable<T>
    {
        Skip.IfNot(
            Environment.GetEnvironmentVariable("XUNIT_UNITY_RUNNER") is null,
            "System.Text.Json 6.0.0+ does not work well with Unity/Mono.");

        var buffer = new MemoryStream();
        JsonSerializer.Serialize(buffer, obj);
        buffer.Seek(0L, SeekOrigin.Begin);
        var options = new JsonSerializerOptions
        {
            AllowTrailingCommas = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        };
        JsonNode actual = JsonSerializer.SerializeToNode(obj, options);
        JsonNode expected = JsonNode.Parse(expectedJson, null, new JsonDocumentOptions
        {
            AllowTrailingCommas = true,
            CommentHandling = JsonCommentHandling.Skip,
        });
        JsonAssert.Equal(expected, actual, true);
        if (testDeserializable)
        {
            var deserialized = JsonSerializer.Deserialize<T>(expectedJson, options);
            Assert.Equal(obj, deserialized);
        }
    }
}
